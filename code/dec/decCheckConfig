#!/usr/bin/env ruby

# == Synopsis
#
# This is a command line tool that checks the coherency of the DEC configuration.
# DEC configuration is distributed amongst different XML files. The information set up
# must be coherent. This tool ensures that all configuration critical elements are correct.
# (All DEC config files must be placed in the $DEC_CONFIG directory). 
# So, run this tool everytime a configuration change is performed.
#
# -e flag:
#
# With this option the Interfaces (Entities) configuration placed in dec_interfaces.xml
# is checked. As well it is checked the coherency between the dec_interfaces.xml
# configuration file and the DEC Inventory (DEC Database).
# (Note: if the network link to a given I/F is broken, the tool will not be able to connect and it
# will report a configuration error of this I/F).
#
#
# -i flag:
#
# With this option the Incoming file-types registered in the dec_incoming_files.xml are checked.
# Mainly what it is done is to check that the interface a File is pulled from is configured in 
# the dec_interfaces.xml file.
#
#
# -m flag:
#
# With this option the DEC Mail configuration placed in the ft_mail_config.xml is checked.
#
#
# -s flag:
#
# With this option the DCC Services configured in the dcc_services.xml file are checked.
# The check performed with this flag is that the executable set in the command of the service
# can be found in the $PATH environment variable.
#
#
# -t flag:
#
# With this option the In-Trays configured in the dec_incoming_files.xml file are checked.
#
#
# -a flag:
#
# This is the all flag, which performs all the checks described before.
#
#
# == Usage
# decCheckConfig [--nodb]
#     -a    checks all DEC configuration
#     -e    [entity] checks specified or all entities configuration in dec_interfaces.xml
#    --nodb no Inventory checks
#     -i    checks incoming pulled file-types configured in dec_incoming_files.xml
#     -o    checks outgoing pushed file-types configured in dec_outgoing_files.xml
#     -m    checks the mail configuration placed in ft_mail_config.xml
#     -t    checks the In-Trays configuration placed in dec_incoming_files.xml
#     -l    checks the log configuration
#     -h    it shows the help of the tool
#     -u    it shows the usage of the tool
#     -v    it shows the version number
#     -V    it performs the execution in Verbose mode
#     -D    it performs the execution in Debug mode     
# 
# == Author
# DEIMOS-Space S.L. (bolf)
#
# == Copyright
# Copyright (c) 2005 ESA - DEIMOS Space S.L.
#

#########################################################################
#
# Data Exchange Component
# 
# Git: $Id: decCheckConfig,v 1.7 2007/12/18 18:21:36 decdev Exp $
#
#########################################################################

require 'rubygems'
require 'getoptlong'
require 'rdoc'

require 'cuc/Log4rLoggerFactory'
require 'ctc/CheckerMailConfig'

require 'dcc/CheckerServiceConfig'

require 'dec/DEC_Environment'
require 'dec/ReadConfigDEC'
require 'dec/ReadInterfaceConfig'
require 'dec/CheckerInterfaceConfig'
require 'dec/CheckerOutgoingFileConfig'
require 'dec/CheckerIncomingFileConfig'
require 'dec/CheckerInTrayConfig'

# Conditional require driven by --nodb flag
# require 'dec/CheckerInventoryConfig'

# checkSent2Entity checks what it has been sent to a given entity.
# It checks in the UploadDir and UploadTemp directories 

@isDebugMode      = false
@isVerboseMode    = false
@isSecure         = false
@checkUploadTmp   = false
@bIncoming        = false
@bOutgoing        = false
@bEntities        = false
@bMail            = false
@bClients         = false
@bAll             = false
@bServices        = false
@bTrays           = false
@isNoDB           = false
@bLog             = false
@interface        = ""

# MAIN script function
def main

   include DEC

   @bShowVersion     = false
   @bShowUsage       = false
   @retVal           = true

   opts = GetoptLong.new(     
     ["--all", "-a",            GetoptLong::NO_ARGUMENT],
	  ["--log", "-l",            GetoptLong::NO_ARGUMENT],
     ["--incoming", "-i",       GetoptLong::NO_ARGUMENT],
     ["--outgoing", "-o",       GetoptLong::NO_ARGUMENT],
     ["--tray", "-t",           GetoptLong::NO_ARGUMENT],
     ["--entities", "-e",       GetoptLong::OPTIONAL_ARGUMENT],
     ["--mail", "-m",           GetoptLong::NO_ARGUMENT],
     ["--services", "-s",       GetoptLong::NO_ARGUMENT],
     ["--usage", "-u",          GetoptLong::NO_ARGUMENT],
     ["--Debug", "-D",          GetoptLong::NO_ARGUMENT],
     ["--version", "-v",        GetoptLong::NO_ARGUMENT],
     ["--Verbose", "-V",        GetoptLong::NO_ARGUMENT],
     ["--help", "-h",           GetoptLong::NO_ARGUMENT],
     ["--nodb", "-n",           GetoptLong::NO_ARGUMENT]
     )
    
   begin
      opts.each do |opt, arg|
         case opt
            when "--Debug"    then @isDebugMode    = true
            when "--Verbose"  then @isVerboseMode  = true
            when "--version"  then @bShowVersion   = true
            when "--help"     then @bShowUsage     = true
            when "--nodb"     then @isNoDB         = true
            when "--incoming" then @bIncoming      = true
            when "--outgoing" then @bOutgoing      = true
            when "--entities" then @interface      = arg.to_s
                                   @bEntities      = true
            when "--services" then @bServices      = true
	         when "--mail"     then @bMail          = true
            when "--all"      then @bAll           = true
            when "--tray"     then @bTrays         = true
				when "--log"      then @bLog           = true
            when "--usage"    then @bShowUsage     = true
         end
      end
   rescue Exception
     exit(99)
   end

   if @bShowVersion == true then
      print("\nESA - DEIMOS-Space S.L. ", File.basename($0), " Version: [#{DEC.class_variable_get(:@@version)}]", "\n\n")
      hRecord = DEC.class_variable_get(:@@change_record)
      hRecord.each_pair{|key, value|
         puts "#{key} => #{value}"
      }      
      exit(0)
   end

   if @bShowUsage == true then
      usage
      exit(0)
   end

   if @bIncoming == false and @bOutgoing == false and @bClients == false and
      @bEntities == false and @bAll == false and @bMail == false and 
      @bServices == false and @bTrays == false and @bLog == false then
      usage
      exit(66)
   end

   if self.checkEnvironmentEssential == false then
      puts
      self.printEnvironmentError
      puts
      exit(99)
   end
    
   checkModuleIntegrity

   @projectName = ReadConfigDEC.instance.getProjectName
   @projectID   = ReadConfigDEC.instance.getProjectID
   
   ftConfig = ReadInterfaceConfig.instance
   arrEnts  = ftConfig.getAllMnemonics

   puts "\nChecking #{@projectName} retrieval of files \n\n"

   # Check of the Entities Configuration
   
   if @bEntities == true or @bAll == true then
      puts "================================================"
      puts "Checking dec_interfaces.xml Configuration ..."
      arrEnts.each{|x|         
         if @interface != "" and @interface != x then
            next
         end
         puts "Verification of interface #{x}"
         bEnabled4Send = ftConfig.isEnabled4Sending?(x)
         bEnabled4Recv = ftConfig.isEnabled4Receiving?(x)

         if bEnabled4Recv == false then
            puts "#{x} is disabled for receiving files"
         end

         if bEnabled4Send == false then
            puts "#{x} is disabled for sending files"
         end

		   checker = CheckerInterfaceConfig.new(x, bEnabled4Recv, bEnabled4Send)
                 
         if @isDebugMode == true or @isVerboseMode then
            checker.setDebugMode
         end
                 
         retVal     = checker.check

         if retVal == true then
            puts "#{'1F44D'.hex.chr('UTF-8')} #{x} I/F is configured correctly"
         else
            puts "#{'1F4A9'.hex.chr('UTF-8')} #{x} I/F is not configured correctly\n"
            @retVal = retVal
         end
      }      
      puts "================================================"

      if @isNoDB == false then
         
         require 'dec/CheckerInventoryConfig'
      
         # Perform the check against the Inventory
         puts "Checking DEC/Inventory entries ..."
         checkerInventory = CheckerInventoryConfig.new
         ret = checkerInventory.check(@interface)
         puts "================================================"
         if ret == false then
            puts "\ntry registering them with decConfigInterface2DB tool !  ;-) \n\n"
            @retVal = ret
         end
      end
      
   end

   # Check that all Incoming File Types have associated Entities registered
   # in dec_interfaces.xml
   
   if @bOutgoing == true  then
      ret = checkOutgoingConfig
      
      if ret == true then
         exit(0)
      else
         exit(99)
      end
   end
   
   if @bIncoming == true or @bAll == true then
      ftReadIncoming   = ReadConfigIncoming.instance   
      arrIncomingFiles = ftReadIncoming.getAllIncomingFiles  
      puts
      puts "================================================"
      puts "Checking dec_incoming_files.xml Configuration ..."
      puts
      ret = true
      arrIncomingFiles.each{|x|
         puts "Check incoming filetype #{x} \n"

	      checker = CheckerIncomingFileConfig.new(x)
	 
         retVal  = checker.check
         
         if retVal == false then 
            ret      = false
            @retVal  = retVal
         end
         
         if retVal == true and @isVerboseMode == true then
            puts "#{x} - OK"
            puts
         end
      }
   
      arrIncomingFiles = ftReadIncoming.getAllIncomingFiles  

      arrIncomingFiles.each{|x|
         puts "Check incoming files like #{x} \n"

	      checker = CheckerIncomingFileConfig.new(x)
	 
         retVal  = checker.check
         
         if retVal == false then 
            ret      = false
            @retVal  = retVal
         end
         
         if retVal == true and @isVerboseMode == true then
            puts "#{x} - OK"
            puts
         end
      }

      checker = CheckerInTrayConfig.new
	   
      if @isDebugMode == true then
         checker.setDebugMode
      end
      
      retVal  = checker.check

      if retVal == false then 
         ret      = false
         @retVal  = retVal
      end

      if ret == true then
         puts "\ndec_incoming_files.xml is configured correctly ! #{'1F44D'.hex.chr('UTF-8')}\n"
      else
         puts "\ndec_incoming_files.xml is not configured correctly ! :-( \n"
      end     
      puts "================================================"
   end

## ==============================================================================


## ==============================================================================

   if @bAll == true or @bMail == true then
      puts "================================================"
      puts "Checking ft_mail_config.xml Configuration ..."
      puts
 
      mailChecker = CTC::CheckerMailConfig.new
      
      if @isDebugMode == true or @isVerboseMode then
         mailChecker.setDebugMode
      end
      
      # retVal = mailChecker.check(true, true)
      
      # 20181025 integration only for the notification delivery
      
      retVal = mailChecker.check(true, false)
      
      if retVal == true then
         puts "\nft_mail_config.xml is configured correctly ! :-) \n"
      else
         puts "\nft_mail_config.xml is not configured correctly ! :-( \n"
         @retVal = retVal
      end
      puts "================================================"         
   end

	if @bAll == true or @bLog == true then
		puts "Checking log configuration"
      begin
	   
   	   loggerFactory = CUC::Log4rLoggerFactory.new("decCheckConfig", "#{ENV['DEC_CONFIG']}/dec_log_config.xml")
            
         @logger = loggerFactory.getLogger
         if @logger == nil then
            puts
	         puts "Error in decCheckConfig::main"
		      puts "Could not set up logging system !  :-("
            puts "Check DEC logs configuration under \"#{ENV['DEC_CONFIG']}/dec_log_config.xml\"" 
		      puts
		      puts
		      exit(99)
         end

         @logger.info("I can write :o)")

		rescue Exception => e
		   puts
      	puts e.to_s
			puts
   	end
	end
   
#    # Check that dcc_services.xml is correctly configured
# 
#    if @bAll == true or @bServices == true then
# #      puts
#       puts "================================================"
#       puts "Checking dcc_services.xml Configuration ..."
#       puts
#  
#       checker = DCC::CheckerServiceConfig.new
#       
#       if @isDebugMode == true or @isVerboseMode then
#          checker.setDebugMode
#       end
#       
#       retVal = checker.check
#       
#       if retVal == true then
#          puts "\ndcc_services.xml is configured correctly ! :-) \n"
#       else
#          puts "\ndcc_services.xml is not configured correctly ! :-( \n"
#       end
#       puts "================================================"         
#    end
   
   if @retVal == true then
      exit(0)
   else
      exit(99)
   end
   
end

## -------------------------------------------------------------

def checkOutgoingConfig

   failed               = Array.new
   ftReadOutgoing       = ReadConfigOutgoing.instance   
   arrOutgoingFiles     = ftReadOutgoing.getAllOutgoingTypes
      
   puts
   puts "================================================"
   puts "Checking dec_outgoing_files.xml Configuration ..."
   puts
      
   ret = true
   
      
      if arrOutgoingFiles.empty? == false then
         puts
         puts "Wildcards: "
      end

      ret = true
      arrOutgoingFiles.each{|x|
         puts "Check outgoing files like #{x} \n"

         # A boolean is passed so the checker knows its a wildcard.
	      # It will check with the specific wildcard methods
	      checker = CheckerOutgoingFileConfig.new(x,true)
	 
         retVal  = checker.check
         
         if retVal == false then ret = false end
         
         if retVal == true then
            puts "#{x} - OK"
         else
            failed << "Error: in #{x} :-("
         end
      }

      if !failed.empty? then
         puts     
         puts "Consider revising the following types/wildcards:"
         puts failed  
      end
      if ret == true then
         puts "\ndec_outgoing_files.xml is configured correctly #{'1F44D'.hex.chr('UTF-8')}\n"
      else
         puts "\nError: dec_outgoing_files.xml is not configured correctly #{'1F480'.hex.chr('UTF-8')}\n"
      end     
      puts "================================================"
   
      return ret
end

## -------------------------------------------------------------
   
## Check that everything needed by the class is present.
def checkModuleIntegrity
   return
end 

## -------------------------------------------------------------
##
## Print command line help
def usage
   fullpathFile = File.expand_path(__FILE__)
   
   value = `#{"head -70 #{fullpathFile}"}`
      
   value.lines.drop(1).each{
      |line|
      len = line.length - 1
      puts line[2, len]
   }
end

## -------------------------------------------------------------

## =============================================================================
## Start of the main body
main
## End of the main body
## =============================================================================
