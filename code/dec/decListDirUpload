#!/usr/bin/env ruby

# == Synopsis
#
# This is a DEC command line tool that lists the contents of the <Upload> directory
# corresponding to a given interface configured in interfaces.xml
#
# == Usage
# decListDirUpload -m <Interface_Name> [-t]
#        --mnemonic  <MNEMONIC> (mnemonic is case sensitive)
#        --temp      it shows the content of the <UploadTemp> directory
#        --Show      it shows all available I/Fs registered in the Inventory
#        --help      shows this help
#        --usage     shows the usage
#        --Debug     shows Debug info during the execution
#        --version   shows version number
# 
# == Author
# Deimos-Space S.L. (bolf)
#
# == Copyright
# Copyright (c) 2006 ESA - Deimos Space S.L.
#

#########################################################################
#
# === Ruby script decListDirUpload
# 
# === Written by DEIMOS Space S.L. (bolf)
#
# === Data Exchange Component
# 
# Git: $Id: decListDirUpload,v 1.2 2007/06/26 15:53:35 decdev Exp $
#
# decListDirUpload checks what it has been sent to a given entity.
# It checks in the UploadDir and UploadTemp directories 
#
#########################################################################

require 'getoptlong'

require 'ctc/FTPClientCommands'
require 'dec/DEC_Environment'
require 'dec/ReadInterfaceConfig'
require 'dec/ReadConfigOutgoing'
require 'dec/InterfaceHandlerLocal'
require 'dec/InterfaceHandlerFTPS'
                                   
## MAIN script function
def main
   
   include CTC::FTPClientCommands
   include DEC

   @isDebugMode      = false              
   @isVerboseMode    = false
   @isSecure         = false
   @checkUploadTmp   = false
   @entity           = ""
   @bShowVersion     = false
   @bShowUsage       = false

   opts = GetoptLong.new(
     ["--mnemonic", "-m",       GetoptLong::REQUIRED_ARGUMENT],
     ["--temp", "-t",           GetoptLong::NO_ARGUMENT],     
     ["--Debug", "-D",          GetoptLong::NO_ARGUMENT],
     ["--version", "-v",        GetoptLong::NO_ARGUMENT],
     ["--Verbose", "-V",        GetoptLong::NO_ARGUMENT],
     ["--Show", "-S",           GetoptLong::NO_ARGUMENT],
     ["--help", "-h",           GetoptLong::NO_ARGUMENT]
     )
    
   begin
      opts.each do |opt, arg|
         case opt
            when "--Debug"    then @isDebugMode    = true
            when "--Verbose"  then @isVerboseMode  = true
            when "--version"  then @bShowVersion   = true
            when "--temp"     then @checkUploadTmp = true         
            when "--help"     then @bShowUsage     = true
            when "--mnemonic" then @entity         = arg
            when "--Show"     then @bShowMnemonics = true      
         end
      end
   rescue Exception
     exit(99)
   end
 
   if @bShowVersion == true then
      print("\nESA - DEIMOS-Space S.L. ", File.basename($0), " Version: [#{DEC.class_variable_get(:@@version)}]", "\n\n")
      hRecord = DEC.class_variable_get(:@@change_record)
      hRecord.each_pair{|key, value|
         puts "#{key} => #{value}"
      }      
      exit(0)
   end

   ## --------------------------------------------

   if @bShowUsage == true then
      usage
      exit(0)
   end
   
   ## --------------------------------------------
   
   if self.checkEnvironmentEssential == false then
      puts
      self.printEnvironmentError
      puts
      exit(99)
   end
 
   ## --------------------------------------------
 
   # -----------------------------------------------------------------
   #
   # initialize logger
   loggerFactory = CUC::Log4rLoggerFactory.new("list", "#{ENV['DEC_CONFIG']}/dec_log_config.xml")
   if @isDebugMode then
      loggerFactory.setDebugMode
   end
   @logger = loggerFactory.getLogger
   if @logger == nil then
      puts
		puts "Error in send2Interface::main"
		puts "Could not set up logging system !  :-("
      puts "Check DEC logs configuration under \"#{ENV['DEC_CONFIG']}/dec_log_config.xml\"" 
		puts
		puts
		exit(99)
   end
   # -----------------------------------------------------------------

 
 
   if @bShowMnemonics == true then
   
      require 'dec/DEC_DatabaseModel'
   
      arrInterfaces = Interface.all
      if arrInterfaces == nil then
         puts
         puts "Sorry, there are no configured I/Fs :-|"
         puts
      else
         if arrInterfaces.length == 0 then
            puts
            puts "Sorry, there are no configured I/Fs :-|"
            puts
         else
            puts "=== Data Collector Component Registered I/Fs ==="
            arrInterfaces.each{|interface|
               print interface.name
               1.upto(25 - interface.name.length) do
                  print " "
               end
               print interface.description
               puts
            }         
         end
      end
      exit(0)
   end

   ## --------------------------------------------

   if @entity == "" then
      usage
      exit(99)
   end
   
   ## --------------------------------------------
   
   # Check Module Integrity
   checkModuleIntegrity
   
   @configFile = ReadInterfaceConfig.instance

   ## --------------------------------------------

   if @configFile.exists?(@entity) == false then
      print("\n#{@entity} is not a registered I/F in the dec_interfaces.xml config file !  :-(\n\n")
      exit(99)
   end

   entConf = @configFile.getFTPServer4Send(@entity)  
      
   # ---------------------------------------------
   if entConf[:protocol].upcase == "LOCAL" then
      handler = InterfaceHandlerLocal.new(@entity)
      
      list = handler.getUploadDirList
      
      list.each{|file|
         @logger.debug("I/F #{@entity}:  UploadDir: #{file} found")
      }
      
      if @checkUploadTmp == true then
         list = handler.getUploadDirList(true)
      
         list.each{|file|
            @logger.debug("I/F #{@entity}:  UploadTemp: #{file} found")
         }
      end
      
      exit(0)
   end 
   # ---------------------------------------------
   
   if entConf[:protocol].upcase == "FTPS" or entConf[:protocol].upcase == "FTPES" then
      handler = InterfaceHandlerFTPS.new(@entity, @logger)
      
      if @isDebugMode == true then
         handler.setDebugMode
      end
      
      list = handler.getUploadDirList
      
      list.each{|file|
         @logger.debug("#{@entity} I/F UploadDir: item #{file} found")
      }
      
      if @checkUploadTmp == true then
         list = handler.getUploadDirList(true)
      
         list.each{|file|
            @logger.debug("I/F #{@entity}:  UploadTemp: #{file} found")
         }
      end
            
      exit(0)
   end
   # ---------------------------------------------
   
   if entConf[:isSecure] == true then
      @isSecure = true
   end 
   
   if @isVerboseMode == true then
      showInterfaceConfig(entConf)
   end
   
   if @isSecure == false then
   
#      cmd = self.createCurlFTPList(entConf[:hostname],
#                              entConf[:port],
#                              entConf[:user],
#                              entConf[:password],
#                              ReadConfigOutgoing.instance.getUploadDir(@entity),
#                              entConf[:isPassive],   
#                              nil)
   
      cmd = self.createNcFtpLs(entConf[:hostname],
                              entConf[:port],
                              entConf[:user],
                              entConf[:password],
                              ReadConfigOutgoing.instance.getUploadDir(@entity),
                              entConf[:isPassive],   
                              nil)
   else
      cmd = self.createSftpCommand(entConf[:hostname],
                                  entConf[:port],
                                  entConf[:user],
                                  @batchFile,
                                  "cd #{ReadConfigOutgoing.instance.getUploadDir(@entity)}",
                                  nil,
                                  nil)
      cmd = self.createSftpCommand(entConf[:hostname],
                                  entConf[:port],
                                  entConf[:user],
                                  @batchFile,
                                  "ls",
                                  "-1",
                                  nil)
   end
   
   if @isDebugMode == true then
      puts cmd
   end
   
   puts
   puts "============================================================="
   puts "Checking #{@entity} I/F Upload Directory"
   puts
   retVal = system(cmd)
   puts "============================================================="
   puts
   if @isSecure == true and FileTest.exist?(@batchFile) then
      n = File.delete(@batchFile)
   end     

   # If check to uploadTemp has not been requested, we've finished!.
   if @checkUploadTmp == false then
      if retVal == true then
         exit(0)
      else
         exit(99)
      end
   end

   if @isSecure == false then
#      cmd = self.createCurlFTPList(entConf[:hostname],
#                              entConf[:port],
#                              entConf[:user],
#                              entConf[:password],
#                              ReadConfigOutgoing.instance.getUploadTemp(@entity),
#                              entConf[:isPassive], 
#                              "*")
                              
      cmd = self.createNcFtpLs(entConf[:hostname],
                              entConf[:port],
                              entConf[:user],
                              entConf[:password],
                              ReadConfigOutgoing.instance.getUploadTemp(@entity),
                              entConf[:isPassive],
                              "*")
   else
      cmd = self.createSftpCommand(entConf[:hostname],
                                  entConf[:port],
                                  entConf[:user],
                                  @batchFile,
                                  "cd #{ReadConfigOutgoing.instance.getUploadTemp(@entity)}",
                                  nil,
                                  nil)
      cmd = self.createSftpCommand(entConf[:hostname],
                                  entConf[:port],
                                  entConf[:user],
                                  @batchFile,
                                  "ls",
                                  "",
                                  nil)
   end

   if @isDebugMode == true then
      puts cmd
   end
   
   puts
   puts "============================================================="
   puts "Checking #{@entity} I/F Upload TEMP Directory"
   puts
   retVal = system(cmd)
   puts "============================================================="
   puts
   if @isSecure == true and FileTest.exist?(@batchFile) then
      n = File.delete(@batchFile)
   end     
   
   if retVal == true then
      exit(0)
   else
      exit(99)
   end

   
end

## ---------------------------------------------------------

## ---------------------------------------------------------
##
## Check whether the entity is registered in the config file or not
##
def showInterfaceConfig(entity)
   puts
   puts "============================================================="
   puts "Configuration of #{entity[:mnemonic]} I/F for sending data :"
   puts
   if @isSecure == true then 
     puts "Secure conection is used (sftp)"
   else
     puts "NON Secure conection is used (ftp)"
   end
   puts "hostname     -> #{entity[:hostname]}"
   puts "port         -> #{entity[:port]}"
   puts "user         -> #{entity[:user]}"
   puts "password     -> #{entity[:password]}"
   puts "upload dir   -> #{ReadConfigOutgoing.instance.getUploadDir(@entity)}"
   puts "upload tmp   -> #{ReadConfigOutgoing.instance.getUploadTemp(@entity)}"
   puts
end
## ---------------------------------------------------------

## ---------------------------------------------------------
   
## Check that everything needed by the class is present.
def checkModuleIntegrity
      
   bDefined = true
   bCheckOK = true
   
   if !ENV['DEC_TMP'] then
     puts "\nDEC_TMP environment variable not defined !  :-(\n\n"
     bCheckOK = false
     bDefined = false
   end
   
   if bCheckOK == false then
     puts "decListDirUpload::checkModuleIntegrity FAILED !\n\n"
     exit(99)
   end     
   
   time    = Time.new   
   strTime = time.to_i.to_s
   @batchFile = %Q{#{ENV['DEC_TMP']}/.batchCheckSent2#{@entity}#{strTime}}

end 
## ---------------------------------------------------------

## ---------------------------------------------------------

## Print command line help
def usage
   fullpathFile = File.expand_path(__FILE__)
   
   value = `#{"head -22 #{fullpathFile}"}`
      
   value.lines.drop(1).each{
      |line|
      len = line.length - 1
      puts line[2, len]
   }
end
## ---------------------------------------------------------

## ==========================================================================
## Start of the main body
main
## End of the main body
## ==========================================================================
